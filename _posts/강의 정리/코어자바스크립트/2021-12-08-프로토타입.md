---
title: Javascript prototype
date: 2021-12-08 23:59:00 +0900
categories: [강의정리, 코어 자바스크립트]
tags: [javascript]
math: true
toc: true
mermaid: true
comments: true
image:
  width: 800
  height: 500
pin: true
---

- 이 내용은 코어 자바스크립트의 강의 중 prototype을 정리한 내용 입니다.
- [강의링크](https://www.inflearn.com/course/%ED%95%B5%EC%8B%AC%EA%B0%9C%EB%85%90-javascript-flow/dashboard)


# 프로토타입
- 상속되는 속성과 메소드들이 정의되어 있는 곳의 속성을 의미[^1]
- 생성자 함수와 new[^2] 키워드를 이용해서 instance를 생성하면 Constructor[^3]의 `prototype`이라고 하는 프로퍼티의 내용이 instance의 `[[Prototype]]`라고 하는 프로퍼티로 참조를 전달하게 된다.

## 리터럴의 경우
- 리터럴의 경우에는 instance가 아니므로 `[[Prototype]]`이 존재하지 않는다.
- 하지만 메서드 처럼 접근이 가능한데, 가능한 이유는 javascript에서 타입에 해당되는 객체의 인스턴트를 임시로 만들어서 메서드를 호출하기 때문에 가능하다.
- 메서드 호출이 끝나고 임시로 만든 instance는 삭제 된다.

## 프로토타입 체이닝
- Constructor의 `prototype` Ojbect 생성자 함수의 new 연산으로 생성된 instance이다.
- instance는 모두 `[[Prototype]]`을 가지고 있으므로 Constructor의 `prototype`의 `[[Prototype]]`은 Object의 `prototype`이 된다.
- 따라서 Object의 `prototype` 도 접근할 수 있게 된다.
- 그러므로 Object 전용 메서드를 Object의 `prototype`에 정의하면 안된다. 왜냐면 다른 객체에서 호출 할 수 있기 때문이다.
- 따라서 유독 `Object.xxxx(obj);` 형태의 메서드가 많은 이유가 프로토타입 체이닝 특성 때문이다.

### 예시
- Ararry에는 toString이라는 메서드가 있다. 그래서 배열의 toString을 호출하면 아래와 같이 나오는데, 이는 Array 객체의 `prototype`에 존재하는 toString 메서드를 호출 하기 때문이다.
 
  ```js
  const arr = [1,2,3];
  arr.toString(); // "1,2,3"
  ```

- 만약 Array 객체의 `prototype`에 존재하는 toString를 지우면 다음과 같이 나올 것이다.

  ```js
  const arr = [1,2,3];
  delete Array.prototype.toString;
  arr.toString(); // "[object Array]"
  ```

- 이유는 이제 Array 객체의 `prototype`에는 toString 메서드가 존재 하지 않기 때문에, 프로토타입 체이닝을 통해서 `Object의 prototype`에 존재하는 toString 메서드를 호출 하기 때문이다. 이것도 `스코프 체인`과 비슷하게 근접한 곳에서 부터 탐색한다.


[^1]: 출처 MDN [링크](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes)
[^2]: new 연산자 [링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/new)
[^3]: Constructor: instance의 생성자 함수 (예를들어 배열 instance이면 Array)