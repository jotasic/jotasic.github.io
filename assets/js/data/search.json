[ { "title": "Javascript Iterable, iterator, generator", "url": "/posts/JS-Iterable/", "categories": "강의정리, Javascript ES6+ 제대로 알아보기 - 중급", "tags": "javascript", "date": "2021-12-18 21:00:00 +0900", "snippet": "들어가며 이 내용은 Javascript ES6+ 제대로 알아보기 - 중급 강의 중 Iterable, iterator, generator를 정리한 내용 입니다. 강의링크Iterable내부 요소들을 공개적으로 탐색(반복) 할 수 있는 데이터 구조로 [Symbol.iterator]메소드를 가지고 있다.[Symbol.iterator]를 실행한 결과를 가지고, next()를 반복 호출하는 로직을 기반으로 Array.from, spread operator, for .. of 등의 기능들을 실행한다.기본적으로 내장하고 있는 객체는 array, map, set, string 등이 있다.사용자가 규칙에 맞게 [Symbol.iterator]를 구현하면 Iterable한 객체가 될 수 있다.이 외에 Generator도 다른 방식으로 구현되어 있지만 Iterable한 객체이다.Iterator반복을 위해 설계뙨 특별한 인터페이스를 가진 객체 객체 내부에는 next() 메소드가 있는데, 이 메소드는 value와 done 프로퍼티를 지닌 객체를 반환한다. done 프러퍼티는 boolean 값 이다. 이러한 조건을 가진 객체를 반환하도록 객체내 [Symbol.iterator]메소드를 정의해주면 해당 객체는 Iterable한 객체가 된다. done 프러퍼티가 true가 될 때까지 next()메소드를 호출한다. 따라서 done 프로퍼티가 true가 되지 않는 조건으로 Iterator를 만들면 안된다.Generator 중간에서 멈췄다가 이어서 실행할 수 있는 함수. function 키워드 뒤에 *를 붙여 표현하며, 함수 내부에는 yield 키워드를 활용한다. 함수 실행 결과에 대해 next() 메소드를 호출할 때마다 순차적으로 제너레이터 함수 내부의 yield 키워드를 만나기 전까지 실행하고, yield 키워드에서 일시정지한다.const generator = function* () { yield 1; yield 2; yield 3;}const gen = generator();console.log(`gen()`, gen.next()); // {value:1, done: false}console.log(`gen()`, gen.next()); // {value:2, done: false}console.log(`gen()`, gen.next()); // {value:3, done: false}console.log(`gen()`, gen.next()); // {value:undefine, done: true}generator를 이용한 iterator 구현[Symbol.iterator]를 generator로 만들면 yield만 신경쓰면 된다. iterator의 조건은 next() 메소드를 가지고, 그 메소드는 done과 value를 반환하는 객체이기 때문에 가능하다. // 1. generator로 구현 const obj = { *[Symbol.iterator]() { for(let count=1 ; count &amp;lt;= 3 ; count++) { yield count; } }}// 2. iterator객체를 직접 구현const iter = { count: 1, next() { const done = this.count &amp;gt; 3; return { done, value: !done? this.count++ : undefined } }}const obj = { [Symbol.iterator](){ return iter; }}console.log(`obj`, [...obj]);yield*Generator내에서 사용되며, Iterable한 객체의 값들을 yield를 차례대로 호출한 형태의 의미이다.function* gen() { const arr = [1,2,3,4,5]; yield* arr; /* 아래와 같다 yield 1 yield 2 yield 3 yield 4 yield 5 */}" }, { "title": "Javascript Symbol", "url": "/posts/JS-Symbol/", "categories": "강의정리, Javascript ES6+ 제대로 알아보기 - 중급", "tags": "javascript", "date": "2021-12-17 23:20:00 +0900", "snippet": "들어가며 이 내용은 Javascript ES6+ 제대로 알아보기 - 중급 강의 중 Symbol를 정리한 내용 입니다. 강의링크Symbol ES6에서 새로 추가된 자료형 유일무이하고 고유한 존재 비공개 멤버에 대한 요구에서 탄생 기본적인 열거대상에서 제외 암묵적 형변환 불가유일무의하고 고유한 존재Symbol를 생성할 때 같은 string을 부여한다해도 둘을 다르다고 평가한다.따라서 생성할 때 Symbol을 저장하고 있는 변수가 계속 필요하다. const sy1 = Symbol(&#39;symbol&#39;); const sy2 = Symbol(&#39;symbol&#39;); sy1 === sy2; // falseSymbol를 이용한 비공개 멤버 구현obj라는 함수는 객체를 반환하는 기능을 가지고 있는 함수 이다._name이라는 Symbol를 생성해서 반환할 객체에 프로퍼티명으로 지정하였다.obj 함수 밖에서는 _name 값을 알 수 없기 때문에(유일무의한 값이기 때문에) 제공해주는 getter, setter를 이용해서 name을 조작해야될 수 밖에 없다.이러써 name 프로퍼티를 은닉화 할 수 있게 되었다.const obj = () =&amp;gt; { const _name = Symbol(); return { [_name]: &#39;&#39;, get name() { return this[_name]; }, set name(name) { if(name?.length &amp;gt; 0) { this[_name] = name; } } }}const x = obj();x.name = &#39;Tom&#39;물론 Reflect.ownKeys() 를 이용해서 객체에 속한 Symbol도 뽑을 수 있지만 뽑아낸 Symbol이 어떠한 의미인지 모르기 때문에 실제 사용단계에서는 접근하기가 불가능 할 것이다." }, { "title": "Javascript Arrow Function", "url": "/posts/JS-Arrow-Function/", "categories": "강의정리, Javascript ES6+ 제대로 알아보기 - 초급", "tags": "javascript", "date": "2021-12-13 17:10:00 +0900", "snippet": "들어가며 이 내용은 Javascript ES6+ 제대로 알아보기 - 초급 강의 중 Arrow Function 내용을 정리하였습니다. 강의링크Arrow function 표기법const 함수명 = (인자) =&amp;gt; { //함수 구현부}Arrow function 축약 구현부가 1줄이며, 리턴을 해야되는 값이라면, {} 및 return를 생략할 수 있다. // var fa = function() { // return new Date(); // } const fa = () =&amp;gt; new Date(); 다만 리턴해야되는 값이 객체 선언일때, {}는 함수의 구현부로 인식하므로 ()로 객체를 감싸야 된다. const fo = () =&amp;gt; ({a:10, b:20}); 인자가 1개면 ()를 생략할 수 있다. // var fb = function(a) { // return a * a; // } const fb = a =&amp;gt; a * a; 기존 함수 선언과 차이점 this를 바인딩 하지 않는다. 즉 this의 값은 scope chain에 의해서 결정된다. 반대로 말하면 this를 call이나 apply를 이용해서 설정 이나 변경을 할 수 없다. prototype이 존재하지 않는다. 즉 arrow function는 함수로써만 사용하도록 설계되었다." }, { "title": "Javascript 추가된 Object 기능", "url": "/posts/JS-%EC%B6%94%EA%B0%80%EB%90%9C-Object-%EA%B8%B0%EB%8A%A5/", "categories": "강의정리, Javascript ES6+ 제대로 알아보기 - 초급", "tags": "javascript", "date": "2021-12-13 12:00:00 +0900", "snippet": "들어가며 이 내용은 Javascript ES6+ 제대로 알아보기 - 초급 강의 중 enhanced Object functionalities 내용을 정리하였습니다. 강의링크Shorthand property프로퍼티의 key와 value에 할당할 변수명이 동일할 경우 value 생략 가능기존var x = 10;var y = 20;var obj = { x: x, y: y}변경var x = 10;var y = 20;var obj = { x, y}concised method메소드를 축약해서 쓸 수 있다.var obj = { name: &#39;foo&#39;, getName () {return this.name}}기존 선언과 다른점 arguments, caller가 함수 호출 당시에만 접근 가능하다. prototype이 없다. 즉 생성자 함수가 없으므로 인스턴스 생성을 못한다 (함수의 기능으로만 사용 가능) super를 이용해서 부모 오브젝트의 정의된 같은 이름의 메소드 호출 가능computed property (계산된 프로퍼티 명)대괄호 표기법을 객체 안에서도 사용가능 하도록 추가const name = &#39;test&#39;;var obj = { [&#39;test1&#39;]: &#39;foo&#39;, [`${name}2`]: foo2}" }, { "title": "Javascript block scope", "url": "/posts/JS-%EB%B8%94%EB%A1%9D%EC%8A%A4%EC%BD%94%ED%94%84/", "categories": "강의정리, Javascript ES6+ 제대로 알아보기 - 초급", "tags": "javascript", "date": "2021-12-12 22:30:00 +0900", "snippet": "들어가며 이 내용은 Javascript ES6+ 제대로 알아보기 - 초급 강의 중 Block scope 내용을 정리하였습니다. 강의링크Block scope Block에 의해 생기는 유효범위 (for, if, while….) var는 block scope에 영향을 받지 않고, let, const만 영향을 받는다. Block scope는 this bind를 하지 않는다. 즉 Block 밖에 있는 this와 동일하다.예시var는 Block scope의 영향을 받지 않으므로 이전에 정의된 10을 출력var a = 10;{ console.log(`a`, a); // 10 var a = 10;}const는 Block scope의 영향을 받고, 정의되기 전에 참조를 하면 reference Error가 난다. 이 구간을 TDZ라고 한다.const a = 10;{ console.log(`a`, a); // reference Error const a = 10;} TDZ: Temporal Dead Zone (임시사각지대) &amp;lt;/br&amp;gt;Ecmascript에서 정의한 개념은 아님 let이나 const에서는 실제로 정의한 부분에부터 호출 이 가능" }, { "title": "Javascript prototype", "url": "/posts/JS-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/", "categories": "강의정리, 코어 자바스크립트", "tags": "javascript", "date": "2021-12-08 23:59:00 +0900", "snippet": "들어가며 이 내용은 코어 자바스크립트의 강의 중 prototype과 class를 정리한 내용 입니다. 강의링크프로토타입 상속되는 속성과 메소드들이 정의되어 있는 곳의 속성을 의미1 생성자 함수와 new2 키워드를 이용해서 instance를 생성하면 Constructor3의 prototype이라고 하는 프로퍼티의 내용이 instance의 [[Prototype]]라고 하는 프로퍼티로 참조를 전달하게 된다.리터럴의 경우 리터럴의 경우에는 instance가 아니므로 [[Prototype]]이 존재하지 않는다. 하지만 메서드 처럼 접근이 가능한데, 가능한 이유는 javascript에서 타입에 해당되는 객체의 인스턴트를 임시로 만들어서 메서드를 호출하기 때문에 가능하다. 메서드 호출이 끝나고 임시로 만든 instance는 삭제 된다.프로토타입 체이닝 Constructor의 prototype은 Object 생성자 함수의 new 연산으로 생성된 instance이다. instance는 모두 [[Prototype]]을 가지고 있으므로 Constructor의 prototype의 [[Prototype]]은 Object의 prototype이 된다. 따라서 Object의 prototype 도 접근할 수 있게 된다. 그러므로 Object 전용 메서드를 Object의 prototype에 정의하면 안된다. 왜냐면 다른 객체에서 호출 할 수 있기 때문이다. 따라서 유독 Object.xxxx(obj); 형태의 메서드가 많은 이유가 프로토타입 체이닝 특성 때문이다.예시 Ararry에는 toString이라는 메서드가 있다. 그래서 배열의 toString을 호출하면 아래와 같이 나오는데, 이는 Array 객체의 prototype에 존재하는 toString 메서드를 호출 하기 때문이다. const arr = [1,2,3];arr.toString(); // &quot;1,2,3&quot; 만약 Array 객체의 prototype에 존재하는 toString를 지우면 다음과 같이 나올 것이다. const arr = [1,2,3];delete Array.prototype.toString;arr.toString(); // &quot;[object Array]&quot; 이유는 이제 Array 객체의 prototype에는 toString 메서드가 존재 하지 않기 때문에, 프로토타입 체이닝을 통해서 Object의 prototype에 존재하는 toString 메서드를 호출 하기 때문이다. 이것도 스코프 체인과 비슷하게 근접한 곳에서 부터 탐색한다. 프로토타입을 응용한 class 구현ES6 전에는 javascript에 class라는 키워드가 존재하지 않았다.따라서 아래와 같이 구현한다.기본적인 구현 방법 부모, 자식 객체의 생성자 함수를 만든다. (Food, Apple) 부모 객체에서 자식 객체에게 상속시킬 메서드를 prototype에 정의 한다. 자식의 prototype을 부모의 새로운 instance로 대체한다. 자식의 prototype의 constructor는 부모의 객체로 대체 되었기 때문에 다시 자식의 객체로 변경한다.function Food(color){ this.color = color;}function Apple(color){ this.color = color;}// 부모 객체에서 자식 객체에게 상속시킬 메서드를 prototype에 정의 한다.Food.prototype.printFoodColor = function() { console.log(`Color:`, this.color);}// 자식의 prototype을 부모의 새로운 instance로 대체한다.Apple.prototype = new Food();// 자식의 prototype의 constructor는 부모의 객체로 대체 되었기 때문에 다시 자식의 객체로 변경한다.Apple.prototype.constructor = Apple;const apple = new Apple(&#39;green&#39;);apple.printFoodColor(); // Color: green기본적인 개념은 다음과 같은데, 여기서 보완해야될 부분이 있다. Food의 color가 Apple의 prototype에 남게 된다. Apple에도 color를 지정하고 Food에서도 color를 지정하는 코드 중복이 일어난다.보완한 구현 방법 1 - 중복 프로퍼티 제거 Bridge라는 빈 객체를 만든다. Bridge의 prototype에 부모의 prototype을 대입한다. Bridge의 새로운 인스턴스를 자식의 prototype에 대입한다.// Bridge라는 빈 객체를 만든다.function Bridge(){};// Bridge의 prototype에 부모의 prototype을 대입한다.Bridge.prototype = Food.prototype;// Bridge의 새로운 인스턴스를 자식의 prototype에 대입한다.Apple.prototype = new Bridge(); Apple.prototype.constructor = Apple;const apple = new Apple(&#39;green&#39;);apple.printFoodColor();이렇게 되면 기존에 Food에서는 생성자를 통해서 color이라는 속성이 생겼지만 Bridge 생성자에서는 아무것도 하지 않으므로 color라는 속성이 생기지 않게되므로, Food의 prototype만을 Apple에게 상속시킬 수 있게 된다.보완한 구현 방법 2 - 생성자 함수 중복코드 제거 Bridge라는 빈 객체를 만든다. Bridge의 prototype에 부모의 prototype을 대입한다. Bridge의 새로운 인스턴스를 자식의 prototype에 대입한다. (여기까지 동일) 자식의 prototype의 superClass에 부모를 지정한다. (이름은 상관없음) 자식 생성자 함수에서 superClass를 호출한다. 호출된 superClass는 메서드로써 호출되었기 때문에 thisBind에 의해서 this가 자식의 instance가 되므로 color가 자식의 instance의 프로퍼티가 된다.function Food(color){ this.color = color;}function Apple(color){ // 자식 생성자 함수에서 superClass를 호출한다. this.superClass(color);}// Bridge라는 빈 객체를 만든다.function Bridge(){};// Bridge의 prototype에 부모의 prototype을 대입한다.Bridge.prototype = Food.prototype;// Bridge의 새로운 인스턴스를 자식의 prototype에 대입한다.Apple.prototype = new Bridge(); Apple.prototype.constructor = Apple;// 자식의 prototype의 superClass에 부모를 지정한다.Apple.prototype.superClass = Food; const apple = new Apple(&#39;green&#39;);apple.printFoodColor();참고 - 상속관계를 함수화위와 같은 코드의 구성은 부모 자식 관계를 맺을 때마다 작성하는 귀찮다.따라서 아래와 같은 함수를 만들어서 쉽게 상속관계를 맺을 수 있도록 하는것을 추천하고 있다고 한다.var extendClass = (function() { function Bridge(){} return function(Parent, Child) { Bridge.prototype = Parent.prototype; Child.prototype = new Bridge(); Child.prototype.constructor = Child; Child.prototype.superClass = Parent; }})();extendClass(Food, Apple); 출처 MDN 링크 &amp;#8617; new 연산자 링크 &amp;#8617; Constructor: instance의 생성자 함수 (예를들어 배열 instance이면 Array) &amp;#8617; " }, { "title": "Javascript 클로저", "url": "/posts/JS-%ED%81%B4%EB%A1%9C%EC%A0%80/", "categories": "강의정리, 코어 자바스크립트", "tags": "javascript", "date": "2021-12-08 14:30:00 +0900", "snippet": "들어가며 이 내용은 코어 자바스크립트의 강의 중 클로저를 정리한 내용 입니다. 강의링크클로저란?컨텍스트 A에서 선언한 변수 a를 참조하는 내부함수 B를 A의 외부로 전달할 경우, A가 종료된 이후에도 a가 사라지지 않는 현상.즉 지역변수가 함수 종료 후에도 사라지지 않게 할 수 있음.아래 함수에서 outer의 반환값은 inner 함수 입니다.원래 같으면 outer함수가 종료되면 outer의 실행 컨텍스트가 사라져야 되는데, inner쪽에서 outer의 a변수를 참조하므로 func이 함수로 호출될때, outer의 a변수에 대한 정보가 필요하다.따라서 outer의 실행 컨택스트가 남아있게 된다.function outer(){ var a = 10; function inner() { a++; return a; } return inner;}const func = outer()재미있는점은 a라는 변수는 inner에서 조작이 가능하지만 밖에서는 접근이 불가하다. 이점을 이용하면 캡슐화를 할 수 있다." }, { "title": "Javascript 실행 컨텍스트(execution context)와 this", "url": "/posts/JS-%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-this/", "categories": "강의정리, 코어 자바스크립트", "tags": "javascript", "date": "2021-12-08 14:15:00 +0900", "snippet": "들어가며 이 내용은 코어 자바스크립트의 강의 중 실행 컨텍스트와 this를 정리한 내용 입니다. 강의링크실행 컨텍스트함수를 실행할 때 필요한 조건 및 환경정보(전역공간, 함수, eval1, module)실행 컨텍스트의 구조 VariableEnvironment : 식별자 정보 수집 (실행중 변화 반영x) LexicalEnvironment : 각 식별자의 데이터 추적(실행중 변화 반영o) ThisBindingLexicalEnvironment실행컨텍스트를 구성하는 환경 정보들을 모아 사전처럼 구성한 객체 environmentRecord : 현재 컨텍스트 내의 식별자 정보(호이스팅2 개념과 일치) outerEnvironmentReference : 외부 환경에 대한 참조(외부 LexicalEnvironment) 이것을 이용해서 scope chain 이 일어남식별자 정보 수집 과정 (호이스팅 과정)참조코드console.log(a());function a() { return &#39;a&#39;;}var b = function bb() { return &#39;bb&#39;;} 함수의 정보를 수집한다. 변수의 정보를 수집한다.(값은 수집하지 않음)결과environmentRecord{ function a() {...}, b: undefined}Scope chain 과정(inner() 함수 관점에서 기술) 처음에 console.log에 a값은 선언이 되어 있기는 하지만 아직 값이 할당되지 않은 상태이므로 undefined가 출력된다. 그 다음에 변수 a에 100이 할당된다. 변수 b의 경우 inner 함수에는 선언되어 있지 않다 따라서 outerEnvironmentReference를 통해서 제일가까운 스코프인 outer의 LexicalEnvironment의 environmentRecord를 참조한다. outer또한 변수 b가 없으므로 outer의 outerEnvironmentReference를 참조한다.(Global Environment) Global Environment에는 변수 b가 정의되어 있고, 값도 할당된 상태이므로 20이 출력된다.var a = 10;var b = 20;function outer(){ console.log(`#Outer`, a); function inner(){ console.log(`#Inner`, a); var a = 100; console.log(`#Inner`, b); } inner();};outer();console.log(`#Global`, a);ThisBindingThis: 자신을 가리키는 식별자를 지칭함수가 호출될 때, 결정된다. 즉 동적으로 할당된다. 전역공간 : 전역객체(window / global) 함수로 호출 : 전역객체(window / global) 메서드로 호출(객체 내에 정의된 함수) : 메서드 호출 주체 a.b() &amp;gt; a가 this가 됨 a.b.c() &amp;gt; a.b가 this가 됨 callback 호출시 기본적으로 함수의 this와 같다(전역객체) 제어권을 가진 함수(콜백을 호출하는)가 콜백의 this를 지정해두는 경우도 있다(call, apply, bind를 이용해서) 생성자함수(new) 호출 시 : 해당 인스턴스 eval: 문자로 표현된 JavaScript 코드를 실행하는 함수 - 사용하지 말것! &amp;#8617; Hoisting: 현재 컨텍스트에 식별자 정보들을 수집해서 environmentRecord 넣는 과정 &amp;#8617; " }, { "title": "Javascript 데이터 타입", "url": "/posts/JS-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/", "categories": "강의정리, 코어 자바스크립트", "tags": "javascript", "date": "2021-12-07 13:00:00 +0900", "snippet": "들어가며 이 내용은 코어 자바스크립트의 강의 중 데이터 타입을 정리한 내용 입니다. 강의링크Primitive Type stack 영역에 저장 Number, String, Boolean, null, undefined, Symbol(ES6)데이터 저장 방식 우선 변수가 선언되면 데이터가 담길 임의의 공간을 확보한다. (1000번) 식별자가 obj이니 이름을 obj로 지정한다. 변수에 값이 할당되면 할당된 값을 임의의 공간에 저장하고, 변수가 할당된 공간을 찾아서 값이 있는 곳의 주소를 넣는다. var obj;obj = 123; 주소 1000 1001 1002 1003 1004 1005 1006 1007 데이터 이름:obj값:@1007             123 만약 값을 바꾸면 새로운 공간의 값을 저장해서 위와 같은 과정을 진행한다. obj = 456 주소 1000 1001 1002 1003 1004 1005 1006 1007 데이터 이름:obj값:@1002   456         123 Reference Type heep 영역에 저장 Object(Function, Array, Set…) 우선 변수가 선언되면 데이터가 담길 임의의 공간을 확보한다. (1000번) 식별자가 obj이니 이름을 obj로 지정한다. Primitive Type과 다르게 Reference Type은 여러개의 값이 올 수 있으므로 다이렉트로 값을 넣지 못한다. 그래서 한 단계를 더 거친다. obj에는 할당될 값의 주소의 범위를 임의로 지정하고, 각 프로퍼티에 대해서 할당한다. 할당하는 방식은 Primitive Type과 같다. var obj;obj = { x: 3, y: 5,}; 주소 1000 1001 1002 1003 1004 1005 1006 1007 데이터 이름:obj값:@1005~?     3 5 이름:x 값:@1003 이름:y 값:@1004   주의점 Reference Type은 값을 복사를 했을 때, 복사된 값의 내부 내용을 바꿔도 원본값이 바뀔 수 있다는 점이 있다참조 카운트 특정 메모리 영역이 참조되는 횟수 참조 카운트가 0이되면 해당 메모리 영역은 가비지 컬렉터에 수거 대상이 된다." }, { "title": "Typescript 연산자를 이용한 타입정의", "url": "/posts/typescript-%EC%97%B0%EC%82%B0%EC%9E%90%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%83%80%EC%9E%85%EC%A0%95%EC%9D%98/", "categories": "Tip, Typescript", "tags": "typescript", "date": "2021-12-04 23:25:00 +0900", "snippet": "연산자를 이용한 타입정의Union Tpye유니온 타입(Union Type)이란 자바스크립트의 OR 연산자와 같이 A이거나 B이다 라는 의미의 타입이다.이처럼 any를 사용하는 경우 마치 자바스크립트로 작성하는 것처럼 동작을 하고 유니온 타입을 사용하면 타입스크립트의 이점을 살리면서 코딩할 수 있다.function logText(age: string | number) { if(typeof age === &#39;number&#39;){ age.toFixed(); return age; } else if (typeof age === &#39;string&#39;){ return age; } return new TypeError(&#39;age must be number or string&#39;);}Union Type을 쓸 때 주의할 점아래와 같이 interface를 이용해서 union type을 사용할때 타입스크립트 관점에서는 함수를 호출하는 시점에 Person도 되고, Developer도 될 수 있으니 이 둘다 포함되는 age만 접근 가능하게 된다.즉 어느 타입이 들어오든 간에 오류가 안 나는 방향으로 타입을 추론하게 됩니다.interface Person { name: string; age: number;}interface Developer { name: string; skill: string;}function introduce(someone: Person | Developer) { someone.name; // O 정상 동작 someone.age; // X 타입 오류 someone.skill; // X 타입 오류}Intersection Type인터섹션 타입(Intersection Type)은 여러 타입을 모두 만족하는 하나의 타입을 의미한다.interface Person{ name: string; age: number;}interface Developer{ name: string; skill: number;}//type Capt = Person &amp;amp; Developer;//orconst test :Person &amp;amp; Developer = { name : &#39;Tom&#39;, age: 20, skill: 100}참고 타입스크립 핸드북" }, { "title": "Typescript 기본타입, 함수, 인터페이스", "url": "/posts/typescript-%EA%B8%B0%EB%B3%B8%ED%83%80%EC%9E%85-%ED%95%A8%EC%88%98-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/", "categories": "Tip, Typescript", "tags": "typescript", "date": "2021-12-04 12:50:00 +0900", "snippet": "타입스크립트 기본 타입타입스크립트에는 12가지 기본타입이 있다.String문자열을 나타냄let str: string = &#39;hi&#39;;Number숫자를 나타냄let num: number = 10;Boolean참/거짓을 나타냄let isLoggedIn: boolean = false;Object이름과 값으로 구성된 프로퍼티의 집합let info = {name : &#39;typescript&#39;, age: 10};Array데이터의 집합let arr: number[] = [1,2,3];// orlet arr: Array&amp;lt;number&amp;gt; = [1,2,3];Tuple배열의 길이가 고정되고 각 요소의 타입이 지정되어 있는 배열 형식let arr: [string, number] = [&#39;hi&#39;, 10];Enum특정 값(상수)들의 집합enum Animal {Dog, Cat, Cow}let animal: Animal = Animal.Dog;// animal is &#39;0&#39;Any모든 타입에 대해서 허용한다는 의미let str: any = &#39;hi&#39;;let num: any = 10;let arr: any = [&#39;a&#39;, 2, true];Void변수에는 undefined와 null만 할당하고, 함수에는 반환 값을 설정할 수 없는 타입let unuseful: void = undefined;function notuse(): void { console.log(&#39;no return&#39;);}Null어떤 값이 의도적으로 비어있음을 표현하며 boolean 연산에서는 거짓으로 취급let hobby: string = null;Undefined정의되지 않은 값을 의미// 정의되지 않은 human을 log로 찍고 있는 모습console.log(human);Never함수의 끝에 절대 도달하지 않는다는 의미를 지닌 타입function neverEnd(): never { while (true) { }}타입스크립트 함수함수의 기본적인 선언기존 자바스크립트 함수의 선언 방식에서 매개변수와 함수의 반환 값에 타입이 추가됨.JSfunction sum(a, b) { return a + b;}TSfunction sum(a: number, b: number): number { return a + b;}?를 이용하면 해당 매개변수를 넘기지 않아도 된다.만약 넘기지 않았다면 b의 값은 undefine 가 된다.function sum(a: number, b?: number): number { return a + b;}다음과 같이 기본값을 설정할 수 있다.매개변수를 넘기지 않았을 시, 설정된 기본값이 된다.function sum(a: number, b=100): number { return a + b;}ES6 문법에서 지원하는 REST 문법은 다음과 같이 사용될 수 있다.function sum(a: number, ...nums: number[]): number{ let totalOfNums = 0; for (let key in nums) { totalOfNums += nums[key]; } return a + totalOfNums;}sum(1,2,3,4,5);인터페이스인터페이스는 상호 간에 정의한 약속 혹은 규칙을 의미한다. 객체의 스펙(속성과 속성의 타입) 함수의 파라미터 함수의 스펙(파라미터, 반환 타입 등) 배열과 객체를 접근하는 방식 클래스객체 선언과 관련된 타입 체킹person interface에 맞는 object만 logName의 인자로 올 수 있다.interface person { age?: number; // 생략가능 name: string; readonly note: string; //읽기 전용 [propName: string]: any; // 인터페이스에서 정의되지 않은 속성을 사용하고 싶을때}function logName(obj: person) { console.log(`obj.name`, obj.name); console.log(`obj.money`, obj.money); }let person = {name: &#39;Tom&#39;, age:33, note:&#39;good person&#39;, money:100000};logName(person);함수 타입함수의 타입을 정할 때에도 사용 가능interface login { (username: string, password: string): boolean; }let loginUser: login;loginUser = function(id: string, pw: string) { console.log(&#39;로그인 했습니다&#39;); return true;}클래스 타입클래스가 일정 조건을 만족하도록 규칙을 정할 수 있음interface CraftBeer { beerName: string; nameBeer(beer: string): void;}class myBeer implements CraftBeer { beerName: string = &#39;Baby Guinness&#39;; nameBeer(b: string) { this.beerName = b; } constructor() {}}인터페이스 확장클래스와 마찬가지로 인터페이스도 확장가능interface Person { name: string;}interface Developer extends Person { skill: string;}let fe = {} as Developer;fe.name = &#39;josh&#39;;fe.skill = &#39;TypeScript&#39;;참고 타입스크립 핸드북 spread 와 rest" }, { "title": "Django ORM 1+N문제", "url": "/posts/Django-ORM-1PN-%EB%AC%B8%EC%A0%9C/", "categories": "Tip, Django", "tags": "django", "date": "2021-12-03 23:55:00 +0900", "snippet": "ORM N+1 문제django ORM은 Lazy-Loading 방식입니다. Lazy-Loading 방식을 사용하면 ORM에서 명령을 실행할 때마다 데이터베이스에서 데이터를 가져오는 것이 아니라 실제로 데이터를 불러와야 할 시점에 데이터베이스에 쿼리를 실행하는 방식입니다.그래서 다음과 같이 QRM를 통해서 db의 data를 접근하면, n+1번 쿼리를 실행하는 것을 확인 할 수 있습니다.In [171]: dogs2 = Dog.objects.filter(id__gt=65540)# owner가 외레키In [172]: for dog in dogs2: print(&quot;Excute querry&quot;) ...: dog.owner.name ...:이 예시에서는 2건의 data를 얻을때, 총 3번의 쿼리를 실행했습니다 (2+1)한번의 호출로 N개의 모델을 가져오고, for loop를 돌면서 실제 데이터를 불러와야되는 시점에 1개의 row를 가져오는 쿼리가 실행되는 것을 확인할 수 있습니다.(0.001) SELECT `dogs`.`id`, `dogs`.`owner_id`, `dogs`.`name`, `dogs`.`age` FROM `dogs` WHERE `dogs`.`id` &amp;gt; 65540; args=(65540,)Excute querry(0.000) SELECT `owners`.`id`, `owners`.`name`, `owners`.`email`, `owners`.`age` FROM `owners` WHERE `owners`.`id` = 17 LIMIT 21; args=(17,)Excute querry(0.000) SELECT `owners`.`id`, `owners`.`name`, `owners`.`email`, `owners`.`age` FROM `owners` WHERE `owners`.`id` = 17 LIMIT 21; args=(17,)그러기 때문에, 이러한 방식은 불러들여야 되는 Row수가 많을 수록 쿼리문 실행 횟수가 많아집니다.Eager-Loading ?Eager-Loading방식은 사전에 쓸 데이터를 포함하여 쿼리를 날리기 때문에 비효율적으로 늘어나는 쿼리 요청을 방지할 수 있습니다.select_related참조하는 대상이 중간테이블이 아닐 시, 쿼리문에서 Join을 이용해서 data를 불러드립니다.바꿔 말하면, 두 테이블간 join을 할 수 있는 구조에서 사용 가능합니다.또한 join을 해서 불러드리기 때문에, 쿼리문은 1번 실행됩니다.마지막으로 중간테이블을 이용해서 관계를 형성하는, many-to-many 모델에서는 사용할 수 없습니다.In [177]: dogs2 = Dog.objects.select_related(&#39;owner&#39;).filter(id__gt=65540)In [178]: for dog in dogs2: ...: dog.owner.name ...:(0.073) SELECT `dogs`.`id`, `dogs`.`owner_id`, `dogs`.`name`, `dogs`.`age`, `owners`.`id`, `owners`.`name`, `owners`.`email`, `owners`.`age` FROM `dogs` INNER JOIN `owners` ON (`dogs`.`owner_id` = `owners`.`id`) WHERE `dogs`.`id` &amp;gt; 65540; args=(65540,)prefetch_related2개의 테이블을 각각 불러드려서, django내에서 합칩니다.select_related을 사용할 수 없는 many-to-many모델에서 사용합니다. 💡 1:1, 1:N 관계에서도 사용가능합니다.dogs2 = Dog.objects.prefetch_related(&#39;owner&#39;).filter(id__gt=65540)for dog in dogs2: dog.owner.name(0.001) SELECT `dogs`.`id`, `dogs`.`owner_id`, `dogs`.`name`, `dogs`.`age` FROM `dogs` WHERE `dogs`.`id` &amp;gt; 65540; args=(65540,)(0.000) SELECT `owners`.`id`, `owners`.`name`, `owners`.`email`, `owners`.`age` FROM `owners` WHERE `owners`.`id` IN (17); args=(17,)헷갈린 점다른테이블을 참조안하고 조회 할 때도, N+1문제가 발생한다고 생각해습니다.다음 예시는 자신의 테이블의 정보만 조회합니다.그럴시에는 쿼리문이 1번만 실행됩니다.dogs2 = Dog.objects.filter(id__gt=65540)In [184]: for dog in dogs2: ...: print(&quot;Excute querry&quot;) ...: dog.name ...:(0.001) SELECT `dogs`.`id`, `dogs`.`owner_id`, `dogs`.`name`, `dogs`.`age` FROM `dogs` WHERE `dogs`.`id` &amp;gt; 65540; args=(65540,)Excute querryExcute querry" }, { "title": "Nestjs 기본 용어 정리", "url": "/posts/Nestjs-%EA%B8%B0%EB%B3%B8-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC/", "categories": "Tip, Nest.js", "tags": "nest.js", "date": "2021-11-30 11:33:00 +0900", "snippet": "NestJSnest-js 구조AppModule(root)├──Module1│ └──Controller│ └──Service│ └──..│ └──..├──Module2│ └──Controller│ └──Service│ └──..│ └──..기본적인 명령어프로젝트 생성npm i -g @nestjs/clinest new project-name모듈생성nest g module module-name컨트롤러 생성컨트롤러는 들어오는 요청을 처리하고 클라이언트에 응답을 반환한다.nest g controller module-name서비스생성서비스 안에는 데이터베이스 관련된 로직을 처리한다.nest g service module-name --no-spec# --no-spce : 테스트 코드 생성 안함Type ORM설치npm install pg typeorm @nestjs/typeorm --save# pg : postgres 모듈# typeorm : typeorm 모듈설정src &amp;gt; configs &amp;gt; typeorm.config.ts 파일을 만든다.import { TypeOrmModuleOptions } from &#39;@nestjs/typeorm&#39;;import * as config from &#39;config&#39;; // 설정 파일 const dbConfig = config.get(&#39;db&#39;);export const typeORMConfig: TypeOrmModuleOptions = { type: dbConfig.type, host: process.env.RDS_HOSTNAME || dbConfig.host, port: process.env.RDS_PORT || dbConfig.port, username: process.env.RDS_USERNAME || dbConfig.username, password: process.env.RDS_PASSWORD || dbConfig.password, database: process.env.RDS_DB_NAME || dbConfig.database, entities: [__dirname + &#39;/../**/*.entity.{js,ts}&#39;], // entity가 정의된 위치 synchronize: dbConfig.synchronize, // true이면 entity가 변경시 해당 table 삭제 후, 다시 생성};Entity 작성db table의 설계도 같은 느낌 (Django에서 Model과 비슷한 느낌) 각각의 모듈폴더 안에 xx.entity.ts에 작성한다.@Entity(&#39;users&#39;)export class User extends BaseEntity { @PrimaryGeneratedColumn() pk: number; @Column() id: string; @Column() password: string; //외레키 설정 // OneToMany이면 Django에서 역참조라고 생각하면 된다.(_set으로 접근) // eager는 해당 모델을 가져올 때, userTires를 가져올지 설정하는 문구이다. @OneToMany((type) =&amp;gt; UserTire, (userTire) =&amp;gt; userTire.user, { eager: false }) userTires: UserTire[];}근데, ts는 카멜케이스 이니깐 컬럼명을 카멜케이스로 하면 db에도 카멜케이스 형태로 들어간다.이것을 DB에 들어갈때는 스네이크 케이스로 하고 싶으면 다음과 같이하면된다.@Column({name:&#39;created_at&#39;})createdAt: Date하지만 이 방법은 번거럽고 실수 할 수 있다. 따라서 typeorm-naming-strategies를 사용해서 자동을 바뀔 수 있도록 한다.export const typeORMConfig: TypeOrmModuleOptions = { // typeORMConfig에 다음과 같이 추가 namingStrategy: new SnakeNamingStrategy(),Repository각 table의 CRUD를 하는 곳Django에서 Manager(objects)랑 비슷한 느낌각각의 모듈폴더 안에 xx.repository.ts에 작성한다.기본적으로 Repository를 상속받은 형태로 작성하고, 추후 필요한 ORM을 메쏘드 형태로 만든다.import { EntityRepository, Repository } from &#39;typeorm&#39;;import { User } from &#39;./users.entity&#39;;@EntityRepository(User)export class UserRepository extends Repository&amp;lt;User&amp;gt; {}만든 Repository를 Module에서 사용할 수 있도록 등록한다.@Module({ imports: [TypeOrmModule.forFeature([UserRepository])],...})service 부분에서 사용하므로 다음과 같이 선언해서 사용한다.ts에서는 생성자의 private 인자로 들어가면 자동으로 맴버 property가 된다.@Injectable()export class UsersService { constructor( @InjectRepository(UserRepository) private userRepository: UserRepository, ) {}}DTO계층간 데이터를 전송하기 위해서 필요한 객체이며, 해당 객체를 만들기 위해서는 아래와 같은 패키지가 필요함.파이프data transformation과data validation을 위해서 사용됨transformation : 정수로 받았는데, 숫자로 변환validation : 유효성 체크npm install class-validator class-transformer --save파이프는 핸들러, 파라미터, 글로벌 레벨 3가지로 나뉨핸들러: 핸들러 하나의 작용(컨토롤러 함수 하나)파라미터 : 파라미터 하나의 적용글로벌 : 모든 요청에 적용로그인/회원 가입bcryptjsbcryptjs 단방향 해쉬 알고리즘으로 회원가입시, 비밀번호를 암호화 하기위해 사용 다양한 언어로 되어 있고 사용방법도 거의 동일한 것 같다. 참고npm install bcryptjs --saveimport * as bcrypt from &#39;bcryptjs&#39;;로그인/인증 jwt: 로그인 시에 인증정보를 암호화한다. passport: 토큰이 유효한지 검사하고 user정보를 반환하는 기능을 수행한다. 참고 npm install @nestjs/jwt @nestjs/passport passport passport-jwt --save Test테스트 파일을 작성하면 에러가 날때가 있다. package.json에서 jest 찾아서 설정을 바꿔주자 &quot;jest&quot;: { &quot;moduleDirectories&quot;: [ &quot;node_modules&quot;, &quot;src&quot; ], &quot;moduleFileExtensions&quot;: [ &quot;js&quot;, &quot;json&quot;, &quot;ts&quot; ], &quot;roots&quot;: [ &quot;src&quot; ], &quot;testRegex&quot;: &quot;.spec.ts$&quot;, &quot;transform&quot;: { &quot;^.+\\\\.(t|j)s$&quot;: &quot;ts-jest&quot; }, &quot;coverageDirectory&quot;: &quot;../coverage&quot;, &quot;testEnvironment&quot;: &quot;node&quot;, &quot;moduleNameMapper&quot;: { &quot;src/(.*)&quot;: &quot;&amp;lt;rootDir&amp;gt;/src/$1&quot; } }" } ]
